<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>单应性矩阵估计方法比较</title>
    <style>
        :root {
            --primary: #3498db;
            --secondary: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --light: #ecf0f1;
            --dark: #34495e;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            margin-bottom: 10px;
        }
        
        .description {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .method-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .method-card {
            background-color: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .method-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        .method-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light);
        }
        
        .method-icon {
            font-size: 1.8em;
            margin-right: 15px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
        }
        
        .dlt .method-icon {
            background-color: var(--primary);
        }
        
        .ransac .method-icon {
            background-color: var(--success);
        }
        
        .lmeds .method-icon {
            background-color: var(--warning);
        }
        
        .method-title {
            flex: 1;
        }
        
        .method-name {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--secondary);
            margin-bottom: 5px;
        }
        
        .method-subtitle {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        
        .method-content {
            margin-top: 20px;
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: bold;
            margin: 15px 0 10px;
            color: var(--secondary);
            border-left: 3px solid var(--primary);
            padding-left: 10px;
        }
        
        .math-equation {
            background-color: #f8f9fa;
            border-left: 4px solid var(--primary);
            padding: 15px;
            margin: 10px 0;
            font-family: 'Cambria Math', 'Times New Roman', serif;
            overflow-x: auto;
            border-radius: 0 8px 8px 0;
        }
        
        .algorithm-steps {
            background-color: #f0f7ff;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .step {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }
        
        .step:before {
            content: "•";
            position: absolute;
            left: 0;
            color: var(--primary);
            font-weight: bold;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px 15px;
            text-align: left;
        }
        
        .comparison-table th {
            background-color: #f2f2f2;
            font-weight: bold;
            color: var(--secondary);
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .comparison-table tr:hover {
            background-color: #f1f1f1;
        }
        
        .visualization {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin: 30px 0;
            gap: 20px;
        }
        
        .vis-item {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .vis-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--secondary);
            text-align: center;
        }
        
        .performance-chart {
            height: 200px;
            background-color: #f8f9fa;
            border-radius: 5px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-bar {
            position: absolute;
            bottom: 0;
            width: 30%;
            transition: height 0.5s ease;
        }
        
        .bar-dlt {
            left: 10%;
            background-color: var(--primary);
            height: 80%;
        }
        
        .bar-ransac {
            left: 40%;
            background-color: var(--success);
            height: 65%;
        }
        
        .bar-lmeds {
            left: 70%;
            background-color: var(--warning);
            height: 50%;
        }
        
        .chart-label {
            position: absolute;
            bottom: -25px;
            text-align: center;
            width: 30%;
            font-size: 0.9em;
        }
        
        .label-dlt {
            left: 10%;
        }
        
        .label-ransac {
            left: 40%;
        }
        
        .label-lmeds {
            left: 70%;
        }
        
        @media (max-width: 768px) {
            .method-comparison {
                grid-template-columns: 1fr;
            }
            
            .visualization {
                flex-direction: column;
            }
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <h1>单应性矩阵估计方法比较</h1>
        <p class="description">详细解析DLT、RANSAC+DLT和LMEDS的数学原理与主要区别</p>
    </header>
    
    <div class="method-comparison">
        <!-- DLT 方法 -->
        <div class="method-card dlt">
            <div class="method-header">
                <div class="method-icon">H</div>
                <div class="method-title">
                    <div class="method-name">直接线性变换 (DLT)</div>
                    <div class="method-subtitle">基于最小二乘的解析解法</div>
                </div>
            </div>
            
            <div class="method-content">
                <div class="section-title">数学原理</div>
                <p>对于点对应关系 \((X_i, Y_i) \leftrightarrow (u_i, v_i)\)，单应性变换可表示为：</p>
                <div class="math-equation">
                    \[
                    \begin{cases}
                    u_i = \frac{h_{11}X_i + h_{12}Y_i + h_{13}}{h_{31}X_i + h_{32}Y_i + h_{33}} \\
                    v_i = \frac{h_{21}X_i + h_{22}Y_i + h_{23}}{h_{31}X_i + h_{32}Y_i + h_{33}}
                    \end{cases}
                    \]
                </div>
                <p>重写为齐次形式：</p>
                <div class="math-equation">
                    \[
                    \begin{cases}
                    h_{11}X_i + h_{12}Y_i + h_{13} - h_{31}X_iu_i - h_{32}Y_iu_i - h_{33}u_i = 0 \\
                    h_{21}X_i + h_{22}Y_i + h_{23} - h_{31}X_iv_i - h_{32}Y_iv_i - h_{33}v_i = 0
                    \end{cases}
                    \]
                </div>
                <p>对于每个点对，构造一个2×9的矩阵 \(A_i\)：</p>
                <div class="math-equation">
                    \[
                    A_i = \begin{bmatrix}
                    -X_i & -Y_i & -1 & 0 & 0 & 0 & X_iu_i & Y_iu_i & u_i \\
                    0 & 0 & 0 & -X_i & -Y_i & -1 & X_iv_i & Y_iv_i & v_i
                    \end{bmatrix}
                    \]
                </div>
                <p>将所有点对应的 \(A_i\) 堆叠成 \(A\) 矩阵，求解 \(Ah = 0\)，其中 \(h = [h_{11}, h_{12}, h_{13}, h_{21}, h_{22}, h_{23}, h_{31}, h_{32}, h_{33}]^T\)。</p>
                
                <div class="section-title">算法步骤</div>
                <div class="algorithm-steps">
                    <div class="step">构造齐次线性系统 \(Ah = 0\)</div>
                    <div class="step">对矩阵 \(A\) 进行奇异值分解 (SVD)：\(A = U \Sigma V^T\)</div>
                    <div class="step">解 \(h\) 是 \(V\) 的最后一列（对应最小奇异值）</div>
                    <div class="step">将 \(h\) 重构为3×3单应性矩阵 \(H\)</div>
                    <div class="step">通常添加约束 \(\|h\| = 1\) 来避免零解</div>
                </div>
                
                <div class="section-title">特点</div>
                <ul>
                    <li><strong>优点</strong>：数学上严谨，计算效率高，对无噪声数据完美</li>
                    <li><strong>缺点</strong>：对异常值非常敏感，需要数据归一化提高数值稳定性</li>
                    <li><strong>适用场景</strong>：高质量数据，无异常值的情况</li>
                </ul>
            </div>
        </div>
        
        <!-- RANSAC+DLT 方法 -->
        <div class="method-card ransac">
            <div class="method-header">
                <div class="method-icon">R+D</div>
                <div class="method-title">
                    <div class="method-name">RANSAC + DLT</div>
                    <div class="method-subtitle">随机抽样一致性算法</div>
                </div>
            </div>
            
            <div class="method-content">
                <div class="section-title">数学原理</div>
                <p>RANSAC 不直接改变DLT的数学原理，而是通过迭代采样来识别和排除异常值：</p>
                <div class="math-equation">
                    \[
                    \text{内点集} = \{ (X_i, Y_i, u_i, v_i) \mid \text{dist}(H(X_i, Y_i), (u_i, v_i)) < \tau \}
                    \]
                </div>
                <p>其中 \(\tau\) 是距离阈值，通常基于重投影误差设定：</p>
                <div class="math-equation">
                    \[
                    \text{dist} = \sqrt{(u_i - \hat{u}_i)^2 + (v_i - \hat{v}_i)^2}
                    \]
                </div>
                <p>迭代次数 \(N\) 的计算：</p>
                <div class="math-equation">
                    \[
                    N = \frac{\log(1 - p)}{\log(1 - (1 - \varepsilon)^s)}
                    \]
                </div>
                <p>其中：
                <ul>
                    <li>\(p\)：置信度（通常0.99）</li>
                    <li>\(\varepsilon\)：异常值比例估计</li>
                    <li>\(s\)：最小样本集大小（单应性估计为4）</li>
                </ul>
                </p>
                
                <div class="section-title">算法步骤</div>
                <div class="algorithm-steps">
                    <div class="step">随机选择4个点对（最小样本集）</div>
                    <div class="step">使用DLT计算单应性矩阵 \(H\)</div>
                    <div class="step">计算所有点对的重投影误差</div>
                    <div class="step">识别内点（误差小于阈值 \(\tau\)）</div>
                    <div class="step">记录内点数量最多的模型</div>
                    <div class="step">重复N次（基于置信度和异常值比例）</div>
                    <div class="step">使用所有内点通过DLT重新估计最终的单应性矩阵</div>
                </div>
                
                <div class="section-title">特点</div>
                <ul>
                    <li><strong>优点</strong>：对异常值鲁棒性强，实际应用广泛</li>
                    <li><strong>缺点</strong>：需要设置阈值参数，计算量较大</li>
                    <li><strong>适用场景</strong>：实际应用中的大多数情况，特别是数据质量不确定时</li>
                </ul>
            </div>
        </div>
        
        <!-- LMEDS 方法 -->
        <div class="method-card lmeds">
            <div class="method-header">
                <div class="method-icon">LM</div>
                <div class="method-title">
                    <div class="method-name">LMEDS</div>
                    <div class="method-subtitle">最小中值平方估计</div>
                </div>
            </div>
            
            <div class="method-content">
                <div class="section-title">数学原理</div>
                <p>LMEDS 最小化残差的中位数，而不是最小二乘中的平方和：</p>
                <div class="math-equation">
                    \[
                    \min_H \text{median}(r_i^2)
                    \]
                </div>
                <p>其中 \(r_i\) 是第 \(i\) 个点对的重投影误差：</p>
                <div class="math-equation">
                    \[
                    r_i = \sqrt{(u_i - \hat{u}_i)^2 + (v_i - \hat{v}_i)^2}
                    \]
                </div>
                <p>LMEDS 的崩溃点（breakdown point）为50%，意味着：</p>
                <div class="math-equation">
                    \[
                    \varepsilon^* = 50\%
                    \]
                </div>
                <p>即当异常值比例不超过50%时，LMEDS 仍能给出合理估计。</p>
                
                <div class="section-title">算法步骤</div>
                <div class="algorithm-steps">
                    <div class="step">随机选择4个点对（最小样本集）</div>
                    <div class="step">使用DLT计算单应性矩阵 \(H\)</div>
                    <div class="step">计算所有点对的重投影误差</div>
                    <div class="step">计算误差平方的中位数</div>
                    <div class="step">记录中位数最小的模型</div>
                    <div class="step">重复多次（基于计算资源）</div>
                    <div class="step">返回中位数最小的单应性矩阵</div>
                </div>
                
                <div class="section-title">特点</div>
                <ul>
                    <li><strong>优点</strong>：不需要设置阈值，对高达50%的异常值鲁棒</li>
                    <li><strong>缺点</strong>：计算复杂度高，对小样本集效果不佳</li>
                    <li><strong>适用场景</strong>：异常值比例较高且计算资源充足的情况</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="visualization">
        <div class="vis-item">
            <div class="vis-title">计算效率比较</div>
            <div class="performance-chart">
                <div class="chart-bar bar-dlt"></div>
                <div class="chart-bar bar-ransac"></div>
                <div class="chart-bar bar-lmeds"></div>
                <div class="chart-label label-dlt">DLT</div>
                <div class="chart-label label-ransac">RANSAC</div>
                <div class="chart-label label-lmeds">LMEDS</div>
            </div>
            <p style="text-align: center; margin-top: 30px;">效率：DLT > RANSAC > LMEDS</p>
        </div>
        
        <div class="vis-item">
            <div class="vis-title">鲁棒性比较</div>
            <div class="performance-chart">
                <div class="chart-bar bar-dlt" style="height: 30%;"></div>
                <div class="chart-bar bar-ransac" style="height: 80%;"></div>
                <div class="chart-bar bar-lmeds" style="height: 90%;"></div>
                <div class="chart-label label-dlt">DLT</div>
                <div class="chart-label label-ransac">RANSAC</div>
                <div class="chart-label label-lmeds">LMEDS</div>
            </div>
            <p style="text-align: center; margin-top: 30px;">鲁棒性：LMEDS ≥ RANSAC > DLT</p>
        </div>
    </div>
    
    <div class="method-card">
        <h2 style="color: var(--secondary); margin-bottom: 20px;">三种方法详细对比</h2>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>DLT</th>
                    <th>RANSAC+DLT</th>
                    <th>LMEDS</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>数学基础</strong></td>
                    <td>最小二乘法，SVD分解</td>
                    <td>随机抽样 + 最小二乘法</td>
                    <td>最小中值平方估计</td>
                </tr>
                <tr>
                    <td><strong>异常值处理</strong></td>
                    <td>无，对异常值敏感</td>
                    <td>通过迭代采样排除异常值</td>
                    <td>通过中值统计抵抗异常值</td>
                </tr>
                <tr>
                    <td><strong>崩溃点</strong></td>
                    <td>0%</td>
                    <td>依赖阈值设置，通常&lt;50%</td>
                    <td>50%</td>
                </tr>
                <tr>
                    <td><strong>计算复杂度</strong></td>
                    <td>O(n)，n为点数</td>
                    <td>O(N·n)，N为迭代次数</td>
                    <td>O(M·n)，M为迭代次数</td>
                </tr>
                <tr>
                    <td><strong>参数需求</strong></td>
                    <td>无</td>
                    <td>需要设置距离阈值和置信度</td>
                    <td>无需参数（或仅需迭代次数）</td>
                </tr>
                <tr>
                    <td><strong>适用场景</strong></td>
                    <td>高质量数据，无异常值</td>
                    <td>实际应用，数据质量不确定</td>
                    <td>高异常值比例，计算资源充足</td>
                </tr>
                <tr>
                    <td><strong>实现难度</strong></td>
                    <td>简单</td>
                    <td>中等</td>
                    <td>中等</td>
                </tr>
            </tbody>
        </table>
        
        <div class="section-title">实际应用建议</div>
        <div class="algorithm-steps">
            <div class="step"><strong>首选RANSAC+DLT</strong>：在大多数实际应用中，这是最平衡的选择，提供了良好的鲁棒性和可接受的计算成本</div>
            <div class="step"><strong>数据质量极高时使用DLT</strong>：当确定数据几乎没有异常值时，DLT是最快且最直接的方法</div>
            <div class="step"><strong>异常值比例高时考虑LMEDS</strong>：当预计有大量异常值（接近50%）且计算资源充足时，LMEDS可能是更好的选择</div>
            <div class="step"><strong>结合使用</strong>：可以先使用RANSAC识别内点，然后对这些内点使用DLT进行精确估计</div>
        </div>
    </div>

    <script>
        // 简单的动画效果
        document.addEventListener('DOMContentLoaded', function() {
            // 添加卡片悬停效果
            const cards = document.querySelectorAll('.method-card');
            cards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-5px)';
                    this.style.boxShadow = '0 6px 12px rgba(0,0,0,0.1)';
                });
                
                card.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 4px 6px rgba(0,0,0,0.05)';
                });
            });
            
            // 图表动画
            setTimeout(() => {
                document.querySelectorAll('.chart-bar').forEach(bar => {
                    const currentHeight = bar.style.height;
                    bar.style.height = '0';
                    setTimeout(() => {
                        bar.style.height = currentHeight;
                    }, 100);
                });
            }, 500);
        });
    </script>
</body>
</html>